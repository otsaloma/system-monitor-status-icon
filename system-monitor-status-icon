#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (C) 2011-2013 Osmo Salomaa
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
A CPU, memory and disk usage monitor status icon.

Requires PyGObject and psutil.
"""

import math
import psutil
import subprocess

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk


class Monitor(Gtk.StatusIcon):

    """A CPU, memory and disk usage monitor status icon."""

    def __init__(self):
        """Initialize, but don't yet start updating."""
        GObject.GObject.__init__(self)
        self.set_from_icon_name("system-monitor-status-icon-1111")
        self.connect("activate", self.on_activate)
        self.connect("popup-menu", self.on_popup_menu)
        self.cpu_times = psutil.cpu_times(percpu=True)
        self.disk_counters = psutil.disk_io_counters()
        self.disk_max = 1 # bytes

    def get_cpu_usage(self):
        """Return CPU usage [0,1] for each processor."""
        t1 = self.cpu_times
        t2 = psutil.cpu_times(percpu=True)
        self.cpu_times = t2
        usage = [0] * len(t1)
        for i in range(len(t1)):
            time1 = t1[i].user + t1[i].system
            time2 = t2[i].user + t2[i].system
            total = sum(t2[i]) - sum(t1[i])
            usage[i] = (time2 - time1) / total
        return usage

    def get_disk_usage(self):
        """Return disk usage [0,1]."""
        bytes1 = self.disk_counters
        bytes2 = psutil.disk_io_counters()
        self.disk_counters = bytes2
        bytes1 = bytes1.read_bytes + bytes1.write_bytes
        bytes2 = bytes2.read_bytes + bytes2.write_bytes
        usage = bytes2 - bytes1
        self.disk_max = max(self.disk_max, usage)
        return usage/self.disk_max

    def get_memory_usage(self):
        """Return memory usage [0,1]."""
        return psutil.phymem_usage().percent/100

    def get_state(self, usage):
        """Return state [1,4] from usage fraction [0,1]."""
        return max(1, min(4, int(math.ceil(usage*4))))

    def on_activate(self, icon):
        """Launch gnome-system-monitor for details."""
        try: subprocess.Popen("gnome-system-monitor")
        except Exception: pass

    def on_popup_menu(self, icon, button, time):
        """Display a menu to allow quitting."""
        menu = Gtk.Menu()
        item = Gtk.MenuItem(label="Quit")
        item.connect("activate", Gtk.main_quit)
        menu.append(item)
        menu.show_all()
        # XXX: This doesn't seem to work.
        # (system-monitor-status-icon:7665): Gdk-CRITICAL **:
        # gdk_device_get_source: assertion `GDK_IS_DEVICE (device)' failed
        menu.popup(parent_menu_shell=None,
                   parent_menu_item=None,
                   func=self.position_menu,
                   data=self,
                   button=button,
                   activate_time=time)

    def update(self):
        """Poll the usage values and update icon."""
        cpu = self.get_cpu_usage()
        memory = self.get_memory_usage()
        disk = self.get_disk_usage()
        self.set_from_icon_name("system-monitor-status-icon-{:d}{:d}{:d}{:d}"
                                .format(self.get_state(min(cpu)),
                                        self.get_state(max(cpu)),
                                        self.get_state(memory),
                                        self.get_state(disk)))

        self.update_tooltip(cpu, memory, disk)
        while Gtk.events_pending():
            Gtk.main_iteration()
        return True # to be called again.

    def update_tooltip(self, cpu, memory, disk):
        """Update detailed information to tooltip."""
        markup = ""
        for i in range(len(cpu)):
            markup += ("<b>CPU:</b>  {: >3.0f} %\n"
                       .format(cpu[i]*100))

        markup += "<b>Mem:</b>  {: >3.0f} %\n".format(memory*100)
        markup += "<b>Disk:</b> {: >3.0f} %".format(disk*100)
        markup = "<tt>{}</tt>".format(markup)
        # Use no-break spaces to avoid linebreaks,
        # which seem to act funky when using tt.
        markup = markup.replace(" ", "\u00a0")
        self.set_tooltip_markup(markup)


if __name__ == "__main__":
    monitor = Monitor()
    GLib.timeout_add_seconds(1, monitor.update)
    Gtk.main()
